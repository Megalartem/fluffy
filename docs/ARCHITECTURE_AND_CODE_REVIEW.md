# Ревью архитектуры и кодовой базы Fluffy

Дата: 2026-02-16

## 1) Контекст и подход

Проведён обзор:
- архитектурных материалов (`README.md`, `docs/ARCHITECTURE.md`),
- структуры проекта,
- репрезентативных модулей (DI, сервисы, хуки, offline/sync),
- статического качества кода через `npm run lint`.

Цель — зафиксировать текущее состояние, выявить риски и предложить приоритизированные улучшения.

---

## 2) Архитектурное ревью

### Что хорошо

1. **Хорошая модульность по feature-срезам**
   - `src/features/*` организованы предсказуемо (`api`, `model`, `hooks`, `ui`), что упрощает локальные изменения.

2. **Явный offline-first вектор**
   - Наличие отдельных контуров `core/offline`, `core/sync`, `core/cloud` формирует правильные boundaries под локальный source of truth и асинхронную синхронизацию.

3. **Наличие архитектурной документации**
   - Для команды уже создана базовая карта системы (потоки данных, паттерны, слои), что снижает bus factor.

### Ключевые архитектурные риски

1. **Документация частично рассинхронизирована с текущим кодом**
   - В README заявлены версии и скрипты, не полностью совпадающие с `package.json` (например, runtime/tooling и наличие `npm test`).
   - Риск: неверные ожидания у новых участников и CI/CD дрейф.

2. **DI-контейнер формально есть, но фактически не является центральной точкой композиции**
   - В `src/shared/di/container.ts` инициализация контейнера отмечена как заготовка, при этом часть сервисов создаётся напрямую (singleton-экспортами).
   - Риск: усложнение тестируемости и контролируемого lifecycle зависимостей.

3. **Смешение ответственности в UI-хуках**
   - В `useTransactions` присутствует не только выборка/фильтрация, но и инициализационные side-effects (seed/cleanup).
   - Риск: неочевидные побочные эффекты, сложность переиспользования и риск повторного выполнения.

4. **Большой технический долг в sync/offline контуре по типизации/чистоте**
   - Судя по lint-результатам, критическая доля ошибок сосредоточена в `core/sync`, `core/offline`, backup-модулях.
   - Риск: именно критический контур надёжности (sync + backup) имеет повышенную вероятность дефектов.

---

## 3) Ревью кодовой базы

### Итоги по качеству (по lint)

- `eslint` завершился с ошибками: **86 проблем (43 errors, 43 warnings)**.
- Основные категории:
  - `@typescript-eslint/no-explicit-any` (многочисленные нарушения),
  - `react-hooks/purity` (impure вызов `Date.now()` в рендере),
  - `prefer-const`,
  - `no-unused-vars`.

### Конкретные наблюдения

1. **Type safety проседает в важных доменных частях**
   - Множество `any` в sync/offline/cloud/backup снижает предсказуемость поведения и ценность TypeScript-строгого режима.

2. **Проблема чистоты рендера в React-компоненте sync UI**
   - В `sync-progress-panel.tsx` вычисление времени через `Date.now()` в render-path нарушает правило idempotent rendering.

3. **Наличие недоиспользуемого/демо-кода в дереве приложения**
   - Существенная часть предупреждений о неиспользуемых переменных в `src/app/test/ui/*`.
   - Для production-ветки лучше изолировать демо-страницы/стаб-код отдельным флагом, test app или storybook-средой.

4. **Репозиторные реализации местами выглядят незавершёнными**
   - Есть признаки недооформленных методов/интерфейсов и точечных style-проблем в in-memory реализациях.

---

## 4) Приоритетный план улучшений

### P0 (сразу)

1. **Стабилизировать качество сборки через lint baseline**
   - Закрыть все `error` категории в первую очередь: `no-explicit-any`, `react-hooks/purity`, `prefer-const`.
   - Ввести правило: PR не проходит без `npm run lint` green.

2. **Убрать impure вычисления из render-пути**
   - Вынести `Date.now()` в effect/ticker-hook или memoized state update интервалом.

3. **Синхронизировать docs и фактическую конфигурацию**
   - Обновить README/ARCHITECTURE под актуальные версии и реальные npm scripts.

### P1 (ближайший спринт)

1. **Нормализовать DI-композицию**
   - Определить единый composition root (например, в app bootstrap) и перевести сервисы на явную инъекцию.

2. **Разделить в хуках query-логику и инициализацию данных**
   - Seed/cleanup вынести в отдельный bootstrap/usecase, не выполнять в типовом read-hook.

3. **Ужесточить типизацию в sync/offline/backup**
   - Заменить `any` на доменные типы (`SyncPayload`, `ConflictEntry`, `BackupSnapshot` и т.д.).

### P2 (последовательно)

1. **Нарастить автоматизированные проверки для критических контуров**
   - Минимум: unit-тесты для conflict resolver, retry strategy, queue processing.

2. **Явно развести demo/test UI и production UI**
   - Ограничить попадание test-страниц в production-политику качества.

3. **Добавить архитектурные decision records (ADR)**
   - Зафиксировать решения по offline-first, sync strategy, DI-подходу и конфликт-резолюции.

---

## 5) Целевые KPI на 2–3 итерации

- `npm run lint`: 0 errors, предупреждения ≤ 10 (или обоснованный baseline).
- Доля `any` в `core/sync`, `core/offline`, `features/backup`: стремится к 0.
- Документация (`README`, `ARCHITECTURE`) полностью соответствует `package.json` и текущей структуре.
- Наличие smoke/unit тестов для sync/offline критического пути.

---

## 6) Краткий вывод

Проект имеет сильный фундамент по модульности и направлению offline-first, но устойчивость в production-сценариях сейчас ограничивается техническим долгом в наиболее критичных подсистемах (sync/offline/backup), а также рассинхронизацией документации и фактической реализации. Приоритет — быстро закрыть quality-gate по lint/error-категориям и стабилизировать композицию зависимостей.
